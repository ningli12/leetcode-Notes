## LC 142. Linked List Cycle II
https://leetcode.com/problems/linked-list-cycle-ii/solution/

Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Notice that you should not modify the linked list.

Example 1:

Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2:

Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3:

Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list.

Two Pointers: fast & slow pointers
HashTable

### 思路
Fast and slow pointer.
Fast pointer moves 2 steps a time, slow pointer 1 step a time.
If the two meet then there's cycle. if fast reach at null at the end, is no cycle
Once they meet, move the fast pointer back to the head, then move it 1 step a time.
When the two meet again, they meet at the entry of the cycle.
```
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null){
            return head;
        }
        
        ListNode fast = head;
        ListNode slow = head;
        
        // A fast pointer will either loop around a cycle and meet the slow
        while(fast !=null && fast.next !=null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow){ //slow and fast meet
                break;
            }
        }
        //pointer reach the `null` at the end is a non-cyclic list
        if(fast == null || fast.next == null) return null;
        
        //put fast from the front of the list
        fast = head;
        while(fast != slow ){ //there is ring, so keep moving until fast == slow
            fast = fast.next;
            slow = slow.next;
        }
        
        return fast;
    }
}
```
Time: O(n)
Space: O(1)


### 方法2，可使用hash set，记录走得节点，如果碰到第一个重复点，则是环的第一个点。
时间复杂度为O(N)，空间复杂度为O(N)
