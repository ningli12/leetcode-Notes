
## LC 109. Convert Sorted List to Binary Search Tree
https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/

Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example 1:

Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST. Example 2:

Input: head = [] Output: [] Example 3:

Input: head = [0] Output: [0] Example 4:

Input: head = [1,3] Output: [3,1]

Constraints:

The number of nodes in head is in the range [0, 2 * 104]. -105 <= Node.val <= 105

- 快慢指针
- 构建数组
- 分治

## 思路
Method 1. Divide and Conquer
Main Idea
If we pick a node as root of the tree, then we will need to determine the left and right subtrees with the list nodes on the left and right hand sides, which is the same problem but with a smaller size.

Also, we want the BST to be balanced, so when constructing the tree, we want to choose the middle list node as the root, so left and right will have same number of nodes, or one side will have an extra node.

Algorithm

Base case: If there is only one node left, return it as a new TreeNode.
Get the middle node.
Recusrivly call the function on the left and right lists and get the left and right subtree.

## CODE
```
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
        if (head.next == null) return new TreeNode(head.val);
        
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        
        ListNode prev = head;
        while (prev.next != slow) {
            prev = prev.next;
        }
        prev.next = null;
        TreeNode left = sortedListToBST(head);
        TreeNode right = sortedListToBST(slow.next);
        TreeNode root = new TreeNode(slow.val);
        root.left = left;
        root.right = right;
        return root;
    }
}

## Complexity Analysis
- Time: O(nlogn), divide and conquer.
- Space: O(height) = O(logn) for recursive calls.


```
