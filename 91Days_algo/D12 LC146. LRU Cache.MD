## 146. LRU Cache
https://leetcode.com/problems/lru-cache/solution/

### 思路
Doubled Linked List and HashMap
分析题目，需要O(1)操作get 和 put。因为设置增删查找，同时保证O(1)，单独的链表或者数组都没办法实现，可采用结合hash table + 链表的方式，hash table方便查找操作，链表方便增加和删除操作。
链表采用双向链表，链表从头到尾表示时间顺序放入的data。头部表面最早的数据，尾部表明最新的数据。同时记录链表的大小，当put操作，如果链表的大小已经达到最大，则需要从链表头部删除一个数据，再在尾部添加一个数据，如果没有达到最大，直接在尾部添加。当get操作，通过hash查找，如果没有，返回-1，如果有，则需要先把该节点移动到最尾部。
hashmap 记录key --> ListNode关系，ListNode中包括前驱和后继节点。增加三个基础函数，包括删除节点，增加节点，移动节点到最后。空间复杂度为O(N)，时间复杂度为O(1)

同时拥有prev和next指针
同时维护head和tail
基于以上两点，可随即挪动元素到末尾
将<key, node>放入map，这样可以访问链表的node
每次get，将对应node移到链表尾部
每次put
如果存在node，则更新map并挪动node到尾部
如果不存在node
如果超过capacity，删除链表头部元素，并删除map内对应key. 这里容易忘记
建<key, node>，put入map，将node放入链表尾部. 这里容易忘记
